use oort_api::prelude::*;

// One radar hit (single scan).
pub struct Contact {
    pub class: Class,
    pub position: Vec2,
    pub velocity: Vec2,
    pub uncertainty_radius: f64,
    pub tick: u32,
}

// One tracked object.
pub struct Track {
    pub class: Class,

    // Anchor = last contact
    pub contact_pos: Vec2,
    pub contact_vel: Vec2,
    pub contact_radius: f64,
    pub contact_tick: u32,

    // Measured accel estimate at contact time (USED FOR AIMING ONLY)
    pub contact_acc: Vec2,

    // Estimate = propagated to "now" (for matching/logic)
    pub est_pos: Vec2,
    pub est_vel: Vec2,
    pub est_radius: f64,
    pub est_tick: u32,

    // propagated accel (aiming only)
    pub est_acc: Vec2,

    // Reacquire logic
    pub reacquire_stage: u8,
    pub reacquire_last_tick: u32,
}

enum RadarMode {
    BootSweep { step: u8 },
    Search,
}

#[derive(Clone, Copy)]
struct CombatProfile {
    gun_speed: Option<f64>,
    fire_angle_eps: f64,
    max_turn_rate_cap: f64,
    uncertainty_penalty: f64,
}

pub struct Ship {
    close_index: u8,
    tracks: Vec<Track>,
    radar_mode: RadarMode,
    reacquire_target: Option<usize>,
    target: Option<usize>,
    fire_latch_target: Option<usize>,
    fire_latch_until_tick: u32,
    aim_jitter: Vec2,
    aim_jitter_until_tick: u32,
}

impl Ship {
    pub fn new() -> Ship {
        Ship {
            close_index: 0,
            tracks: Vec::new(),
            radar_mode: RadarMode::BootSweep { step: 0 },
            reacquire_target: None,
            target: None,
            fire_latch_target: None,
            fire_latch_until_tick: 0,
            aim_jitter: vec2(0.0, 0.0),
            aim_jitter_until_tick: 0,
        }
    }

    // -------------------------
    // Tuning knobs (tracking)
    // -------------------------
    const POS_MULT: f64 = 2.0;
    const VEL_MULT: f64 = 1.5;
    const MAX_VEL_ERROR: f64 = 500.0;

    const REACQUIRE_RADIUS: f64 = 90.0;
    const MAX_TRACK_RADIUS: f64 = 120.0;

    const BEARING_NOISE_FACTOR: f64 = 1e1 * (TAU / 360.0);
    const DISTANCE_NOISE_FACTOR: f64 = 1e4;
    const PRACTICAL_WORST_K: f64 = 7.0;

    // Reacquire throttling: minimum ticks between attempts on same track
    const REACQUIRE_COOLDOWN_TICKS: u32 = 3;

    // -------------------------
    // Tuning knobs (targeting)
    // -------------------------
    const DEFAULT_FIRE_ANGLE_EPS: f64 = 0.01;
    const DEFAULT_MAX_TURN_RATE_CAP: f64 = TAU;
    const DEFAULT_UNCERT_PENALTY: f64 = 0.001;

    // -------------------------
    // Fighter action knobs
    // -------------------------
    const GUN_INDEX: usize = 0;
    const FIGHTER_GUN_SPEED: f64 = 1000.0;

    const OPTIMAL_RANGE_MIN: f64 = 300.0;
    const OPTIMAL_RANGE_MAX: f64 = 600.0;
    const RANGE_GAIN: f64 = 0.3;
    const MAX_CLOSURE_SPEED: f64 = 300.0;

    const MAX_LEAD_TIME: f64 = 3.0;
    const HIGH_UNCERTAINTY_THRESHOLD: f64 = 60.0;
    const HIGH_UNCERTAINTY_LEAD_MULT: f64 = 0.25;

    // Fire control: acquire threshold is tighter than hold threshold for hysteresis
    const FIRE_ACQUIRE_EPS: f64 = 0.060;     // was 0.040
    const FIRE_HOLD_EPS: f64 = 0.120;        // was 0.080
    const FIRE_W_HOLD: f64 = 2.4;            // was 1.2
    const FIRE_LATCH_TICKS: u32 = 12;        // was 6

    // Jitter resampling: adds unpredictability to aim point within uncertainty region
    const JITTER_RESAMPLE_TICKS: u32 = 4;
    const JITTER_MAX_FRACTION: f64 = 0.6;

    // Accel estimation (AIMING ONLY)
    const ACC_SMOOTH: f64 = 0.35; // 0..1 (higher reacts faster)
    const ACC_FADE_TAU: f64 = 5.0; // seconds; accel estimate decays toward 0 with age

    // Radar follow while fighting
    const RADAR_FOLLOW: bool = true;
    const RADAR_WIDE_PING_EVERY: u32 = 25; // occasionally fall back to search scan

    fn wrap_angle(mut a: f64) -> f64 {
        while a > std::f64::consts::PI {
            a -= TAU;
        }
        while a < -std::f64::consts::PI {
            a += TAU;
        }
        a
    }

    fn intercept_time(p_rel: Vec2, v_rel: Vec2, s: f64) -> Option<f64> {
        let a = v_rel.dot(v_rel) - s * s;
        let b = 2.0 * p_rel.dot(v_rel);
        let c = p_rel.dot(p_rel);

        if a.abs() < 1e-6 {
            if b.abs() < 1e-6 {
                return None;
            }
            let t = -c / b;
            return if t.is_finite() && t >= 0.0 { Some(t) } else { None };
        }

        let disc = b * b - 4.0 * a * c;
        if disc < 0.0 {
            return None;
        }
        let sqrt_disc = disc.sqrt();

        let t1 = (-b - sqrt_disc) / (2.0 * a);
        let t2 = (-b + sqrt_disc) / (2.0 * a);

        let mut best = f64::INFINITY;
        if t1.is_finite() && t1 >= 0.0 {
            best = best.min(t1);
        }
        if t2.is_finite() && t2 >= 0.0 {
            best = best.min(t2);
        }

        if best.is_finite() { Some(best) } else { None }
    }

    /// Conservative time-to-turn estimate (used only for lead refinement).
    fn estimate_turn_time(angle_err: f64) -> f64 {
        let ang = angle_err.abs();
        if ang <= 1e-6 {
            return 0.0;
        }
        let amax = max_angular_acceleration().max(1e-6);
        let wcap = Self::DEFAULT_MAX_TURN_RATE_CAP.max(1e-6);
        let t_accel = (2.0 * ang / amax).sqrt();
        let t_cap = ang / wcap;
        t_accel.max(t_cap).min(1.0)
    }

    /// Aiming-only prediction using constant acceleration.
    /// IMPORTANT: does NOT affect uncertainty growth; that's still worst-case elsewhere.
    fn predict_pos_vel_for_aim(t: &Track, dt: f64) -> (Vec2, Vec2) {
        let dt = dt.max(0.0);
        let age_ticks = t.est_tick.saturating_sub(t.contact_tick);
        let age = age_ticks as f64 * TICK_LENGTH;

        // Fade accel estimate toward 0 as it gets stale.
        // exp(-age/tau) style (approx) using clamp + pow for cheap stability.
        let fade = if age <= 0.0 {
            1.0
        } else {
            let x = (-age / Self::ACC_FADE_TAU).exp();
            if x.is_finite() { x } else { 0.0 }
        };

        let a = t.est_acc * fade;

        let p = t.est_pos + t.est_vel * dt + a * (0.5 * dt * dt);
        let v = t.est_vel + a * dt;
        (p, v)
    }

    fn fighter_act(&mut self) {
    f



    fn combat_profile_for_ship_class(c: Class) -> CombatProfile {
        match c {
            Class::Fighter => CombatProfile {
                gun_speed: Some(1000.0),
                fire_angle_eps: Self::DEFAULT_FIRE_ANGLE_EPS,
                max_turn_rate_cap: Self::DEFAULT_MAX_TURN_RATE_CAP,
                uncertainty_penalty: Self::DEFAULT_UNCERT_PENALTY,
            },
            Class::Frigate => CombatProfile {
                gun_speed: None,
                fire_angle_eps: 0.02,
                max_turn_rate_cap: TAU / 2.0,
                uncertainty_penalty: Self::DEFAULT_UNCERT_PENALTY,
            },
            Class::Cruiser => CombatProfile {
                gun_speed: None,
                fire_angle_eps: 0.03,
                max_turn_rate_cap: TAU / 3.0,
                uncertainty_penalty: Self::DEFAULT_UNCERT_PENALTY,
            },
            _ => CombatProfile {
                gun_speed: None,
                fire_angle_eps: 0.03,
                max_turn_rate_cap: TAU / 4.0,
                uncertainty_penalty: Self::DEFAULT_UNCERT_PENALTY,
            },
        }
    }

    fn prune_tracks(&mut self) {
        self.tracks
            .retain(|t| t.est_radius.is_finite() && t.est_radius <= Self::MAX_TRACK_RADIUS);
    }

    fn initial_uncertainty_radius(snr_db: f64, range: f64) -> f64 {
        let error_factor = 10.0_f64.powf(-snr_db / 10.0);

        let sigma_theta = Self::BEARING_NOISE_FACTOR * error_factor;
        let sigma_r = Self::DISTANCE_NOISE_FACTOR * error_factor;

        let sigma_cross = range * sigma_theta;
        let sigma_pos = (sigma_r * sigma_r + sigma_cross * sigma_cross).sqrt();

        let radius = Self::PRACTICAL_WORST_K * sigma_pos;
        if radius.is_finite() { radius } else { 10.0 }
    }

    fn radar_scan(&self) -> Option<Contact> {
        let raw = scan()?;
        let tick = current_tick();

        let my_pos = position();
        let dp = raw.position - my_pos;
        let range = dp.length();

        let radius = Self::initial_uncertainty_radius(raw.snr, range);

        debug!(
            "scan: class={:?} snr={:.3} range={:.0} r0={:.6}",
            raw.class, raw.snr, range, radius
        );

        Some(Contact {
            class: raw.class,
            position: raw.position,
            velocity: raw.velocity,
            uncertainty_radius: radius,
            tick,
        })
    }

    fn max_accel(class: Class) -> f64 {
        match class {
            Class::Fighter => 160.0,
            Class::Frigate => 10.0,
            Class::Cruiser => 5.0,
            Class::Missile => 400.0,
            Class::Torpedo => 70.0,
            _ => 1.0,
        }
    }

    fn propagate_track_estimate(track: &mut Track) {
        let now = current_tick();
        let dt_ticks = now.saturating_sub(track.contact_tick);
        let dt = dt_ticks as f64 * TICK_LENGTH;

        let amax = Self::max_accel(track.class);

        // IMPORTANT: keep estimate for matching simple & stable (constant-velocity)
        track.est_pos = track.contact_pos + track.contact_vel * dt;
        track.est_vel = track.contact_vel;

        // IMPORTANT: uncertainty growth remains WORST-CASE (max accel anywhere)
        track.est_radius = track.contact_radius + 0.5 * amax * dt * dt;
        track.est_tick = now;

        // accel used for aiming only
        track.est_acc = track.contact_acc;
    }

    fn propagate_all_tracks(&mut self) {
        for t in &mut self.tracks {
            Self::propagate_track_estimate(t);
        }
    }

    fn class_compatible(track_class: Class, contact_class: Class) -> bool {
        track_class == contact_class
    }

    fn vel_tolerance(track: &Track) -> f64 {
        let dt_ticks = track.est_tick.saturating_sub(track.contact_tick);
        let dt = dt_ticks as f64 * TICK_LENGTH;
        let a = Self::max_accel(track.class);
        (Self::VEL_MULT * (a * dt)).min(Self::MAX_VEL_ERROR)
    }

    fn pos_tolerance(track: &Track, contact: &Contact) -> f64 {
        Self::POS_MULT * (contact.uncertainty_radius + track.est_radius)
    }

    fn update_tracks_with_contact(&mut self, contact: Contact) -> usize {
        let mut best_idx: Option<usize> = None;
        let mut best_d: f64 = f64::INFINITY;
        let mut best_dv: f64 = f64::INFINITY;

        for (i, track) in self.tracks.iter().enumerate() {
            if !Self::class_compatible(track.class, contact.class) {
                continue;
            }

            let d = (contact.position - track.est_pos).length();
            let pos_tol = Self::pos_tolerance(track, &contact);
            if d > pos_tol {
                continue;
            }

            let dv = (contact.velocity - track.est_vel).length();
            let vel_tol = Self::vel_tolerance(track);
            if dv > vel_tol {
                continue;
            }

            if d < best_d || (d == best_d && dv < best_dv) {
                best_d = d;
                best_dv = dv;
                best_idx = Some(i);
            }
        }

        match best_idx {
            Some(i) => {
                let t = &mut self.tracks[i];

                // Estimate measured acceleration from delta-v / delta-t (aiming only)
                let dt_ticks = contact.tick.saturating_sub(t.contact_tick).max(1);
                let dt = dt_ticks as f64 * TICK_LENGTH;

                let raw_a = (contact.velocity - t.contact_vel) / dt;

                // Clamp accel magnitude by class (prevents noise spikes)
                let amax = Self::max_accel(contact.class);
                let mag = raw_a.length();
                let a_clamped = if mag.is_finite() && mag > amax && amax > 0.0 {
                    raw_a * (amax / mag)
                } else {
                    raw_a
                };

                // Smooth accel estimate
                t.contact_acc = t.contact_acc * (1.0 - Self::ACC_SMOOTH) + a_clamped * Self::ACC_SMOOTH;

                // Update anchor
                t.class = contact.class;
                t.contact_pos = contact.position;
                t.contact_vel = contact.velocity;
                t.contact_radius = contact.uncertainty_radius;
                t.contact_tick = contact.tick;

                t.reacquire_stage = 0;
                t.reacquire_last_tick = 0;

                Self::propagate_track_estimate(t);
                i
            }
            None => {
                let mut t = Track {
                    class: contact.class,

                    contact_pos: contact.position,
                    contact_vel: contact.velocity,
                    contact_radius: contact.uncertainty_radius,
                    contact_tick: contact.tick,

                    contact_acc: vec2(0.0, 0.0),

                    est_pos: contact.position,
                    est_vel: contact.velocity,
                    est_radius: contact.uncertainty_radius,
                    est_tick: contact.tick,

                    est_acc: vec2(0.0, 0.0),

                    reacquire_stage: 0,
                    reacquire_last_tick: 0,
                };

                Self::propagate_track_estimate(&mut t);
                self.tracks.push(t);
                self.tracks.len() - 1
            }
        }
    }

    fn random_space_direction(&self) -> f64 {
        let size = world_size();
        let half = size / 2.0;

        let rx = rand(-half, half);
        let ry = rand(-half, half);
        let random_point = vec2(rx, ry);

        (random_point - position()).angle()
    }

    fn deep_scan(&mut self) {
        let angle = self.random_space_direction();
        set_radar_width(TAU / 3600.0);
        set_radar_heading(angle);

        set_radar_min_distance(0.0);
        set_radar_max_distance(world_size());
    }

    fn close_scan(&mut self) {
        let width = TAU / 4.0;
        let step = TAU / 4.0;

        let angle = (self.close_index as f64) * step;

        set_radar_width(width);
        set_radar_heading(angle);

        set_radar_min_distance(0.0);
        set_radar_max_distance(world_size());

        self.close_index = (self.close_index + 1) % 4;
    }

    fn set_radar_for_mode(&mut self) {
        match self.radar_mode {
            RadarMode::BootSweep { step } => {
                let width = TAU / 4.0;
                let heading = (step as f64) * (TAU / 4.0);

                set_radar_width(width);
                set_radar_heading(heading);

                set_radar_min_distance(0.0);
                set_radar_max_distance(world_size());

                if step >= 3 {
                    self.radar_mode = RadarMode::Search;
                } else {
                    self.radar_mode = RadarMode::BootSweep { step: step + 1 };
                }
            }
            RadarMode::Search => {
                if current_tick() % 10 == 0 {
                    self.close_scan();
                } else {
                    self.deep_scan();
                }
            }
        }
    }

    fn find_reacquire_candidate(&self) -> Option<usize> {
        let now = current_tick();

        // First priority: tracks already in reacquire stage (not on cooldown)
        let mut best_i: Option<usize> = None;
        let mut best_r: f64 = -1.0;

        for (i, t) in self.tracks.iter().enumerate() {
            if t.reacquire_stage > 0
                && now.saturating_sub(t.reacquire_last_tick) >= Self::REACQUIRE_COOLDOWN_TICKS
                && t.est_radius > best_r
            {
                best_r = t.est_radius;
                best_i = Some(i);
            }
        }
        if best_i.is_some() {
            return best_i;
        }

        // Second priority: tracks that need reacquire (not on cooldown)
        best_i = None;
        best_r = -1.0;
        for (i, t) in self.tracks.iter().enumerate() {
            if t.est_radius >= Self::REACQUIRE_RADIUS
                && now.saturating_sub(t.reacquire_last_tick) >= Self::REACQUIRE_COOLDOWN_TICKS
                && t.est_radius > best_r
            {
                best_r = t.est_radius;
                best_i = Some(i);
            }
        }
        best_i
    }

    fn set_radar_reacquire_override(&mut self) -> bool {
        self.reacquire_target = None;

        let Some(i) = self.find_reacquire_candidate() else { return false };
        if i >= self.tracks.len() {
            return false;
        }

        let now = current_tick();

        if self.tracks[i].reacquire_stage == 0 {
            self.tracks[i].reacquire_stage = 1;
        }
        self.tracks[i].reacquire_last_tick = now;

        let stage = self.tracks[i].reacquire_stage;

        let aim = self.tracks[i].est_pos + self.tracks[i].est_vel * TICK_LENGTH;

        let my_pos = position();
        let dp = aim - my_pos;
        let r = dp.length();

        let expand = if stage >= 2 { 2.0 } else { 1.0 };
        let R = self.tracks[i].est_radius * expand;

        set_radar_heading(dp.angle());

        let mut width = if r > 1.0 && R.is_finite() {
            2.0 * (R / r).atan()
        } else {
            TAU / 4.0
        };
        if !width.is_finite() {
            width = TAU / 4.0;
        }
        set_radar_width(width);

        let min_d = (r - R).max(0.0);
        let max_d = r + R;
        set_radar_min_distance(min_d);
        set_radar_max_distance(max_d);

        self.reacquire_target = Some(i);
        true
    }

    fn set_radar_follow_target(&mut self, i: usize) -> bool {
        if !Self::RADAR_FOLLOW {
            return false;
        }
        if i >= self.tracks.len() {
            return false;
        }
        let t = &self.tracks[i];
        if t.reacquire_stage > 0 {
            return false;
        }

        // aim a tick ahead using aiming prediction
        let (aim, _) = Self::predict_pos_vel_for_aim(t, TICK_LENGTH);

        let me = position();
        let dp = aim - me;
        let r = dp.length().max(1.0);

        // Gate around worst-case uncertainty (still worst-case radius!)
        let R = (t.est_radius + 10.0).min(250.0);

        let mut width = 2.0 * (R / r).atan();
        width = width.clamp(TAU / 3600.0, TAU / 90.0);

        set_radar_heading(dp.angle());
        set_radar_width(width);

        set_radar_min_distance((r - R).max(0.0));
        set_radar_max_distance(r + R);

        true
    }

    fn set_radar_for_tick(&mut self) {
        if self.set_radar_reacquire_override() {
            return;
        }

        // Follow current target tightly most ticks while fighting,
        // but occasionally do a wide ping so we don't tunnel forever.
        if let Some(i) = self.target {
            let now = current_tick();
            if now % Self::RADAR_WIDE_PING_EVERY != 0 {
                if self.set_radar_follow_target(i) {
                    return;
                }
            }
        }

        self.set_radar_for_mode();
    }

    fn reacquire_resolve_after_scan(&mut self, updated_idx: Option<usize>) {
        let Some(target_i) = self.reacquire_target.take() else { return };

        if updated_idx == Some(target_i) {
            if let Some(t) = self.tracks.get_mut(target_i) {
                t.reacquire_stage = 0;
                t.reacquire_last_tick = 0;
            }
            return;
        }

        if target_i >= self.tracks.len() {
            return;
        }

        let stage = self.tracks[target_i].reacquire_stage;

        if stage <= 1 {
            self.tracks[target_i].reacquire_stage = 2;
        } else {
            let last_idx_before = self.tracks.len() - 1;
            self.tracks.swap_remove(target_i);

            if target_i != last_idx_before {
                if let Some(ti) = self.target {
                    if ti == target_i {
                        self.target = None;
                    } else if ti == last_idx_before {
                        self.target = Some(target_i);
                    }
                }

                if let Some(fi) = self.fire_latch_target {
                    if fi == target_i {
                        self.fire_latch_target = None;
                    } else if fi == last_idx_before {
                        self.fire_latch_target = Some(target_i);
                    }
                }
            } else {
                if self.target == Some(target_i) {
                    self.target = None;
                }
                if self.fire_latch_target == Some(target_i) {
                    self.fire_latch_target = None;
                }
            }
        }
    }

    fn angle_diff(a: f64, b: f64) -> f64 {
        Self::wrap_angle(a - b).abs()
    }

    fn estimate_time_to_turn(angle_err: f64, amax: f64, wcap: f64, eps: f64) -> f64 {
        if angle_err <= eps {
            return 0.0;
        }
        let t_accel = (2.0 * angle_err / amax.max(1e-6)).sqrt();
        let t_cap = angle_err / wcap.max(1e-6);
        t_accel.max(t_cap)
    }

    fn time_to_fire_at_track(track: &Track, profile: CombatProfile) -> Option<f64> {
        let gun_speed = profile.gun_speed?;
        if gun_speed <= 1.0 {
            return None;
        }

        let me_p = position();
        let me_h = heading();

        let dp = track.est_pos - me_p;
        let range = dp.length();
        if !range.is_finite() || range < 1.0 {
            return None;
        }

        let aim = dp.angle();
        let angle_err = Self::angle_diff(aim, me_h);

        let amax = max_angular_acceleration();
        let t_turn = Self::estimate_time_to_turn(
            angle_err,
            amax,
            profile.max_turn_rate_cap,
            profile.fire_angle_eps,
        );

        let t_proj = range / gun_speed;
        let t_unc = profile.uncertainty_penalty * track.est_radius.max(0.0);

        let t = t_turn + t_proj + t_unc;
        if t.is_finite() { Some(t) } else { None }
    }

    fn select_target_fastest_shot(&self, profile: CombatProfile) -> Option<usize> {
        let mut best_i: Option<usize> = None;
        let mut best_t: f64 = f64::INFINITY;

        for (i, t) in self.tracks.iter().enumerate() {
            if t.reacquire_stage > 0 {
                continue;
            }

            let Some(ttf) = Self::time_to_fire_at_track(t, profile) else { continue };

            if ttf < best_t {
                best_t = ttf;
                best_i = Some(i);
            }
        }

        best_i
    }

    fn update_target_for_tick(&mut self) {
        let my_class = class();
        let profile = Self::combat_profile_for_ship_class(my_class);

        self.target = match my_class {
            Class::Fighter => self.select_target_fastest_shot(profile),
            _ => None,
        };
    }

    fn debug_draw_tracks(&self) {
        let me = position();

        for (i, track) in self.tracks.iter().enumerate() {
            let center = track.est_pos;
            let radius = track.est_radius;

            let color = if Some(i) == self.target { 0xFFAA00 } else { 0x00FF00 };

            draw_line(me, center, color);
            draw_square(center, 10.0, 0xFFFFFF);
            draw_polygon(center, radius, 32, 0.0, 0x00FFFF);

            debug!(
                "track[{i}] class={:?} est_r={:.2} age={} reacq_stage={}{} acc=({:.1},{:.1})",
                track.class,
                track.est_radius,
                track.est_tick.saturating_sub(track.contact_tick),
                track.reacquire_stage,
                if Some(i) == self.target { " [TARGET]" } else { "" },
                track.est_acc.x,
                track.est_acc.y,
            );
        }
    }

    pub fn tick(&mut self) {
        self.propagate_all_tracks();
        self.prune_tracks();

        // pick target BEFORE choosing radar (so radar follow can lock immediately)
        self.update_target_for_tick();

        self.set_radar_for_tick();

        let mut updated_idx: Option<usize> = None;
        if let Some(contact) = self.radar_scan() {
            let idx = self.update_tracks_with_contact(contact);
            updated_idx = Some(idx);
        }

        self.reacquire_resolve_after_scan(updated_idx);
        self.prune_tracks();

        self.fighter_act();
        self.debug_draw_tracks();
    }
}
